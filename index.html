<!doctype html>

<html lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>VATIC-JS: A pure Javascript video annotation tool</title>
    <style>
      .output { font-family: monospace; font-weight: bold; }

      #doodle {
        position: relative;
        width: 0px;
        height: 0px;
        z-index: 2;
      }

      #canvas {
        z-index: 1;
      }

      .bbox {
        border: 1px solid #FF0000;
        position: absolute;
        z-index: 3;
      }

      .handle, .ui-resizable-handle {
        width: 11px;
        height: 11px;
        border-radius: 50%;
        border: 1px solid rgba(255, 0, 0, .5);
        background-color: rgba(255, 255, 0, .15);
        position: absolute;
      }

      .center-drag {
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        cursor: move;
      }

      .ui-resizable-n {
        left: 50%;
        transform: translate(-50%, -50%);
        cursor: n-resize;
      }

      .ui-resizable-s {
        left: 50%;
        bottom: 0%;
        transform: translate(-50%, 50%);
        cursor: s-resize;
      }

      .ui-resizable-w {
        top: 50%;
        transform: translate(-50%, -50%);
        cursor: w-resize;
      }

      .ui-resizable-e {
        right: 0%;
        top: 50%;
        transform: translate(50%, -50%);
        cursor: e-resize;
      }
    </style>
  </head>
  <body>
    <h1>VATIC-JS: A pure Javascript video annotation tool</h1>

    <ol>
      <li>
        <p>This tool can be used to easily annotate a video, without having to install anything.</p>
        <p>Optical flow is used to track your annotations, so that have to do as little work as possible ;-)</p>
        <p>This tool works best in Chrome, and has also been successfully tested in Firefox.</p>
      </li>
      <li>
        <p>To start a new video annotation, select a video file: <input type="file" id="videoFile" accept="video/*" /></p>
        <p>To resume a previous annotation, select a frames zip archive: <input type="file" id="zipFile" accept=".zip" /></p>
        <p>Note: Keep the focus on the browser during the entire extraction process, or frames might be skipped.</p>
        <p class="output" id="videoDimensions"></p>
        <p class="output" id="extractionProgress"></p>
      </li>
      <li>
        <p>Download the extracted frames zip archive: <input type="button" id="downloadFrames" value="Get frames zip archive" disabled="disabled" /></p>
      </li>
      <li>
        <p>Optional: Load an existing <a href="http://web.mit.edu/vondrick/vatic/" target="new">VATIC</a>-compatible XML annotation file.</p>
        <p>This is useful for example if:</p>
        <ul>
          <li>You are resuming a previous annotation.</li>
          <li>You already have a first version of your automatic object detector, which you want to improve by manually correcting its errors.</li>
        </ul>
        <p>Note: Launch your object detector on the extracted frames rather than on the original video to avoid frame/annotation mismatches!</p>
      </li>
      <li>
        <p>Manually annotate the frame sequence:</p>
        <div id="doodle">
          <canvas id="canvas"></canvas>
        </div>
        <p><input type="button" id="play" value="Play" disabled="true" /><input type="button" id="pause" value="Pause" disabled="true" style="display: none;" /></p>
        <p><label for="speed">Speed multiplier: </label><input type="text" id="speed" value="1.00" size="4" /></p>
        <p>Tip: Zoom in with your browser to place the bounding boxes more accurately.</p>
      </li>
      <li>
        <p>Download the <a href="http://web.mit.edu/vondrick/vatic/" target="new">VATIC</a>-compatible XML annotations file.</p>
      </li>
    </ol>

    <script type="text/javascript" src="dist/compatibility.js"></script>
    <script type="text/javascript" src="dist/jszip.js"></script>
    <script type="text/javascript" src="dist/StreamSaver.js"></script>
    <script type="text/javascript" src="dist/polyfill.js"></script>
    <script type="text/javascript" src="dist/jsfeat.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/pouchdb/6.0.7/pouchdb.min.js"></script>
    <script src="https://code.jquery.com/jquery-1.12.4.js"></script>
    <script src="https://code.jquery.com/ui/1.12.1/jquery-ui.js"></script>
    <script type="text/javascript" src="vatic.js"></script>
    <script type="text/javascript">
      "use strict";

      let config = {
        // Should be higher than real FPS to not skip real frames
        // Hardcoded due to JS limitations
        fps: 30,

        // Low rate decreases the chance of losing frames with poor browser performances
        playbackRate: 0.4,

        // Format of the extracted frames
        imageMimeType: 'image/jpeg',
        imageExtension: '.jpg',

        // Name of the extracted frames zip archive
        framesZipFilename: 'extracted-frames.zip'
      };

      let doodle = document.querySelector('#doodle');
      let canvas = document.querySelector('#canvas');
      let ctx = canvas.getContext('2d');
      let videoFile = document.querySelector('#videoFile');
      let zipFile = document.querySelector('#zipFile');
      let videoDimensionsElement = document.querySelector('#videoDimensions');
      let extractionProgressElement = document.querySelector('#extractionProgress');
      let downloadFramesButton = document.querySelector('#downloadFrames');
      let playButton = document.querySelector('#play');
      let pauseButton = document.querySelector('#pause');
      let speedInput = document.querySelector('#speed');

      let framesManager = new FramesManager();
      let annotatedObjectsTracker = new AnnotatedObjectsTracker(framesManager);

      let player = {
        currentFrame: 0,
        isPlaying: false,
        isReady: false,
        timeout: null,

        initialize: function() {
          this.currentFrame = 0;
          this.isPlaying = false;
          this.isReady = false;

          playButton.disabled = true;
          playButton.style.display = 'block';
          pauseButton.disabled = true;
          pauseButton.style.display = 'none';

          for (let i = 0; i < doodle.childNodes.length; i++) {
            let child = doodle.childNodes[i];
            if (child.className == 'bbox') {
              doodle.removeChild(child);
            }
          }
        },

        ready: function() {
          this.isReady = true;

          playButton.disabled = false;
        },

        play: function() {
          if (!this.isReady) {
            return;
          }

          this.isPlaying = true;

          playButton.disabled = true;
          playButton.style.display = 'none';
          pauseButton.disabled = false;
          pauseButton.style.display = 'block';

          this.nextFrame();
        },

        pause: function() {
          if (!this.isReady) {
            return;
          }

          this.isPlaying = false;
          if (this.timeout != null) {
            clearTimeout(this.timeout);
            this.timeout = null;
          }

          pauseButton.disabled = true;
          pauseButton.style.display = 'none';
          playButton.disabled = false;
          playButton.style.display = 'block';
        },

        toogle: function() {
          if (!this.isPlaying) {
            this.play();
          } else {
            this.pause();
          }
        },

        nextFrame: function() {
          if (!this.isPlaying) {
            return;
          }

          if (this.currentFrame >= framesManager.frames.totalFrames()) {
            this.done();
            return;
          }

          annotatedObjectsTracker.getFrameWithObjects(this.currentFrame).then((frameWithObjects) => {
            if (!this.isPlaying) {
              return;
            }

            ctx.drawImage(frameWithObjects.img, 0, 0);

            for (let i = 0; i < frameWithObjects.objects.length; i++) {
              let object = frameWithObjects.objects[i];
              let annotatedObject = object.annotatedObject;
              let annotatedFrame = object.annotatedFrame;
              if (annotatedFrame.isVisible()) {
                annotatedObject.dom.style.display = 'block';
                annotatedObject.dom.style.width = annotatedFrame.bbox.width + 'px';
                annotatedObject.dom.style.height = annotatedFrame.bbox.height + 'px';
                annotatedObject.dom.style.left = annotatedFrame.bbox.x + 'px';
                annotatedObject.dom.style.top = annotatedFrame.bbox.y + 'px';
              } else {
                annotatedObject.dom.style.display = 'none';
              }
            }

            this.currentFrame++;
            this.timeout = setTimeout(() => this.nextFrame(), 1000 / (config.fps * parseFloat(speedInput.value)));
          });
        },

        done: function() {
          this.currentFrame = 0;
          this.isPlaying = false;

          playButton.disabled = false;
          playButton.style.display = 'block';
          pauseButton.disabled = true;
          pauseButton.style.display = 'none';
        }
      };

      videoFile.addEventListener('change', extractionFileUploaded, false);
      zipFile.addEventListener('change', extractionFileUploaded, false);
      playButton.addEventListener('click', playClicked, false);
      pauseButton.addEventListener('click', pauseClicked, false);
      downloadFramesButton.addEventListener('click', downloadFrames, false);

      function playClicked() {
        player.play();
      }

      function pauseClicked() {
        player.pause();
      }

      function downloadFrames() {
        let zip = new JSZip();

        let processed = 0;
        let totalFrames = framesManager.frames.totalFrames();
        for (let i = 0; i < totalFrames; i++) {
          framesManager.frames.getFrame(i).then((blob) => {
            zip.file(i + '.jpg', blob);

            processed++;
            if (processed == totalFrames) {
              let writeStream = streamSaver.createWriteStream('extracted-frames.zip').getWriter();
              zip.generateInternalStream({type: 'uint8array', streamFiles: true})
                 .on('data', data => writeStream.write(data))
                 .on('end', () => writeStream.close())
                 .resume();
            }
          });
        }
      }

      function initializeCanvasDimensions(img) {
        doodle.style.width = img.width + 'px';
        doodle.style.height = img.height + 'px';
        canvas.width = img.width;
        canvas.height = img.height;
      }

      function extractionFileUploaded() {
        if (this.files.length != 1) {
          return;
        }

        videoFile.disabled = true;
        zipFile.disabled = true;
        downloadFramesButton.disabled = true;
        player.initialize();

        let promise;
        if (this == videoFile) {
          let dimensionsInitialized = false;

          promise = extractFramesFromVideo(
            config,
            this.files[0],
            (percentage, framesSoFar, lastFrameBlob) => {
              blobToImage(lastFrameBlob).then((img) => {
                if (!dimensionsInitialized) {
                  dimensionsInitialized = true;
                  initializeCanvasDimensions(img);
                }
                ctx.drawImage(img, 0, 0);

                videoDimensionsElement.innerHTML = 'Video dimensions determined: ' + img.width + 'x' + img.height;
                extractionProgressElement.innerHTML = (percentage * 100).toFixed(2) + ' % completed. ' + framesSoFar + ' frames extracted.';
              });
            });
        } else {
          promise = extractFramesFromZip(config, this.files[0]);
        }

        promise.then((frames) => {
          extractionProgressElement.innerHTML = 'Extraction completed. ' + frames.totalFrames() + ' frames captured.';
          if (frames.totalFrames() > 0) {
            frames.getFrame(0).then((blob) => {
              blobToImage(blob).then((img) => {
                initializeCanvasDimensions(img);
                ctx.drawImage(img, 0, 0);
                videoDimensionsElement.innerHTML = 'Video dimensions determined: ' + img.width + 'x' + img.height;

                framesManager.set(frames);
                player.ready();

                playButton.disabled = false;
                downloadFramesButton.disabled = false;
              });
            });
          }

          videoFile.disabled = false;
          zipFile.disabled = false;
        });
      }

      function bboxify(dom, onChange) {
        let bbox = $(dom);
        bbox.addClass('bbox');

        let createHandleDiv = (className) => {
          let handle = document.createElement('div');
          handle.className = className;
          bbox.append(handle);
          return handle;
        };

        bbox.resizable({
          containment: 'parent',
          handles: {
            n: createHandleDiv('ui-resizable-handle ui-resizable-n'),
            s: createHandleDiv('ui-resizable-handle ui-resizable-s'),
            e: createHandleDiv('ui-resizable-handle ui-resizable-e'),
            w: createHandleDiv('ui-resizable-handle ui-resizable-w')
          },
          stop: (e, ui) => {
            let position = bbox.position();
            onChange(Math.round(position.left), Math.round(position.top), Math.round(bbox.width()), Math.round(bbox.height()));
          }
        });

        bbox.draggable({
          containment: 'parent',
          handle: createHandleDiv('handle center-drag'),
          stop: (e, ui) => {
            let position = bbox.position();
            onChange(Math.round(position.left), Math.round(position.top), Math.round(bbox.width()), Math.round(bbox.height()));
          }
        });
      }

      let mouse = {
        x: 0,
        y: 0,
        startX: 0,
        startY: 0
      };

      let tmpAnnotatedObject = null;

      doodle.onmousemove = function (e) {
        let ev = e || window.event;
        if (ev.pageX) {
          mouse.x = ev.pageX;
          mouse.y = ev.pageY;
        } else if (ev.clientX) {
          mouse.x = ev.clientX;
          mouse.y = ev.clientY;
        }
        mouse.x -= doodle.offsetLeft;
        mouse.y -= doodle.offsetTop;

        if (tmpAnnotatedObject !== null) {
          tmpAnnotatedObject.width = Math.abs(mouse.x - mouse.startX);
          tmpAnnotatedObject.height = Math.abs(mouse.y - mouse.startY);
          tmpAnnotatedObject.x = (mouse.x - mouse.startX < 0) ? mouse.x : mouse.startX;
          tmpAnnotatedObject.y = (mouse.y - mouse.startY < 0) ? mouse.y : mouse.startY;

          tmpAnnotatedObject.dom.style.width = tmpAnnotatedObject.width + 'px';
          tmpAnnotatedObject.dom.style.height = tmpAnnotatedObject.height + 'px';
          tmpAnnotatedObject.dom.style.left = tmpAnnotatedObject.x + 'px';
          tmpAnnotatedObject.dom.style.top = tmpAnnotatedObject.y + 'px';
        }
      }

      doodle.onclick = function (e) {
        if (doodle.style.cursor != 'crosshair') {
          return;
        }

        if (tmpAnnotatedObject != null) {
          let annotatedObject = new AnnotatedObject();
          annotatedObject.dom = tmpAnnotatedObject.dom;
          let bbox = new BoundingBox(tmpAnnotatedObject.x, tmpAnnotatedObject.y, tmpAnnotatedObject.width, tmpAnnotatedObject.height);
          annotatedObject.add(new AnnotatedFrame(player.currentFrame, bbox, true));
          annotatedObjectsTracker.annotatedObjects.push(annotatedObject);
          tmpAnnotatedObject = null;

          bboxify(
            annotatedObject.dom,
            (x, y, width, height) => {
              let bbox = new BoundingBox(x, y, width, height);
              annotatedObject.add(new AnnotatedFrame(player.currentFrame, bbox, true));
            }
          );

          doodle.style.cursor = 'default';
        } else {
          mouse.startX = mouse.x;
          mouse.startY = mouse.y;

          let dom = document.createElement('div');
          dom.className = 'bbox';
          dom.style.left = mouse.x + 'px';
          dom.style.top = mouse.y + 'px';
          doodle.appendChild(dom);
          tmpAnnotatedObject = { dom: dom };
        }
      }

      // Keyboard shortcuts
      document.body.onkeyup = function(e) {
        if (e.code === 'Space') {
          e.preventDefault();
          player.toogle();
        } else if (e.code === 'KeyN') {
          doodle.style.cursor = 'crosshair';
        } else if (e.code === 'Escape') {
          if (tmpAnnotatedObject != null) {
            doodle.removeChild(tmpAnnotatedObject.dom);
            tmpAnnotatedObject = null;
          }

          doodle.style.cursor = 'default';
        }
      }
    </script>
  </body>
</html>
