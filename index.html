<!doctype html>

<html lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>VATIC-JS: A pure Javascript video annotation tool</title>
    <style>
      .output { font-family: monospace; font-weight: bold; }
    </style>
  </head>
  <body>
    <video id="video" style="display: none;"></video>

    <h1>VATIC-JS: A pure Javascript video annotation tool</h1>

    <ol>
      <li>
        <p>This tool can be used to easily annotate a video, without having to install anything.</p>
        <p>Optical flow is used to track your annotations, so that have to do as little work as possible ;-)</p>
        <p>This tool works best in Chrome, and has also been successfully tested in Firefox.</p>
      </li>
      <li>
        <p>To start a new video annotation, select a video file: <input type="file" id="videoFile" accept="video/*" /></p>
        <p>To resume a previous annotation, select a frames zip archive: <input type="file" id="zipFile" accept=".zip" /></p>
        <p>Note: Keep the focus on the browser during the entire extraction process, or frames might be skipped.</p>
        <p class="output" id="videoDimensions"></p>
        <p class="output" id="extractionProgress"></p>
      </li>
      <li>
        <p>Download the extracted frames zip archive: <button id="downloadFrames">Get frames zip archive</button></p>
      </li>
      <li>
        <p>Optional: Load an existing <a href="http://web.mit.edu/vondrick/vatic/" target="new">VATIC</a>-compatible XML annotation file.</p>
        <p>This is useful for example if:</p>
        <ul>
          <li>You are resuming a previous annotation.</li>
          <li>You already have a first version of your automatic object detector, which you want to improve by manually correcting its errors.</li>
        </ul>
        <p>Note: Launch your object detector on the extracted frames rather than on the original video to avoid frame/annotation mismatches!</p>
      </li>
      <li>
        <p>Manually annotate the frame sequence:</p>
        <canvas id="canvas"></canvas>
        <p><input type="button" id="control" /></p>
        <p>Tip: Zoom in with your browser to place the bounding boxes more accurately.</p>
      </li>
      <li>
        <p>Download the <a href="http://web.mit.edu/vondrick/vatic/" target="new">VATIC</a>-compatible XML annotations file.</p>
      </li>
    </ol>

    <script type="text/javascript" src="dist/compatibility.js"></script>
    <script type="text/javascript" src="dist/jszip.js"></script>
    <script type="text/javascript" src="dist/FileSaver.js"></script>
    <script type="text/javascript">
      // Should be higher than real FPS to not skip real frames
      // Hardcoded due to JS limitations
      var fps = 30;

      // Low rate decreases the chance of losing frames with poor browser performances
      var playbackRate = 0.4;

      var video = document.querySelector('#video');
      var canvas = document.querySelector('#canvas');
      var ctx = canvas.getContext('2d');
      var videoFile = document.querySelector('#videoFile');
      var zipFile = document.querySelector('#zipFile');
      var videoDimensionsElement = document.querySelector('#videoDimensions');
      var extractionProgressElement = document.querySelector('#extractionProgress');
      var downloadFramesButton = document.querySelector('#downloadFrames');
      var controlButton = document.querySelector('#control');

      videoFile.addEventListener('change', extractFramesFromVideo, false);
      zipFile.addEventListener('change', extractFramesFromArchive, false);

      controlButton.addEventListener('click', controlClicked, false);
      downloadFramesButton.addEventListener('click', downloadFrames, false);

      var frames;

      // Initialize state
      extractionStarting(true);

      function extractionStarting(isInitialization = false) {
        if (!isInitialization) {
          videoFile.disabled = true;
          zipFile.disabled = true;
        }

        frames = [];
        controlButton.value = 'Play';
        controlButton.disabled = true;
        downloadFramesButton.disabled = true;
      }

      function extractionFoundDimensions(width, height) {
        canvas.width = width;
        canvas.height = height;
        videoDimensionsElement.innerHTML = 'Video dimensions determined: ' + canvas.width + 'x' + canvas.height;
      }

      function extractionProgressed(percentage, framesSoFar) {
        extractionProgressElement.innerHTML = (percentage * 100).toFixed(2) + ' % completed. ' + framesSoFar + ' frames extracted.';
      }

      function extractionCompleted() {
        extractionProgressElement.innerHTML = 'Extraction completed. ' + frames.length + ' frames captured.';
        videoFile.disabled = false;
        zipFile.disabled = false;
        controlButton.disabled = false;
        downloadFramesButton.disabled = false;
      }

      function extractFramesFromVideo() {
        if (this.files.length == 0) {
          return;
        }

        var lastApproxFrame = -1;
        var frameCounter = 0;
        var processed = 0;

        extractionStarting();

        function onBrowserAnimationFrame() {
          if (video.ended) {
            if (processed == frameCounter) {
              ended();
            }
            return;
          }

          compatibility.requestAnimationFrame(onBrowserAnimationFrame);

          if (video.readyState !== video.HAVE_CURRENT_DATA &&
              video.readyState !== video.HAVE_FUTURE_DATA &&
              video.readyState !== video.HAVE_ENOUGH_DATA) {
            return;
          }

          extractionProgressed(video.currentTime / video.duration, processed);

          var currentApproxFrame = Math.round(video.currentTime * fps);
          if (currentApproxFrame != lastApproxFrame) {
            lastApproxFrame = currentApproxFrame;
            frameCounter++;

            var _ = function(frameNumber) {
              ctx.drawImage(video, 0, 0);
              canvas.toBlob(
                function(blob) {
                  processed++;
                  frames[frameNumber] = blob;
                  if (video.ended && processed == frameCounter) {
                    ended();
                  }
                },
                'image/jpeg');
            }(frameCounter - 1);
          }
        }

        function ended() {
          if (video.src != '') {
            URL.revokeObjectURL(video.src);
            video.src = '';
            extractionCompleted();
          }
        }

        video.autoplay = false;
        video.muted = true;
        video.loop = false;
        video.addEventListener(
          'loadedmetadata',
          function onMetadata(e) {
            video.removeEventListener('loadedmetadata', onMetadata);
            compatibility.requestAnimationFrame(onBrowserAnimationFrame);
            extractionFoundDimensions(video.videoWidth, video.videoHeight);
          },
          false);
        video.src = URL.createObjectURL(this.files[0]);
        video.playbackRate = playbackRate;
        video.play();
      }

      function extractFramesFromArchive() {
        if (this.files.length == 0) {
          return;
        }

        extractionStarting();

        JSZip.loadAsync(this.files[0])
             .then(function(zip) {
               var total = 0;
               for (var i = 0; ; i++) {
                 var frame = zip.file(i + '.jpg');
                 if (frame == null) {
                   total = i;
                   break;
                 }
               }

               var processed = 0;
               for (var i = 0; i < total; i++) {
                 var _ = function (frameNumber) {
                   var frame = zip.file(frameNumber + '.jpg');
                   frame.async('arraybuffer')
                        .then(function(content) {
                          processed++;
                          frames[frameNumber] = new Blob([ content ]);
                          if (frameNumber == 0) {
                            var img = new Image();
                            img.onload = function(e) {
                              extractionFoundDimensions(this.width, this.height);
                              URL.revokeObjectURL(this.src);
                            };
                            img.src = URL.createObjectURL(frames[0]);
                          }
                          extractionProgressed(processed / total, processed);

                          if (processed == total) {
                            extractionCompleted();
                          }
                        });
                 }(i);
               }
             });
      }

      function downloadFrames() {
        var zip = new JSZip();
        for (var i = 0; i < frames.length; i++) {
          zip.file(i + '.jpg', frames[i]);
        }
        zip.generateAsync({type:"blob"})
           .then(function (blob) { saveAs(blob, "extracted-frames.zip"); });
      }

      var lastFrame = 0;
      var nextFrameTimeout = null;

      function controlClicked() {
        if (this.value == 'Play') {
          this.value = 'Pause';
          nextFrame();
        } else if (this.value == 'Replay') {
          this.value = 'Pause';
          lastFrame = 0;
          nextFrame();
        } else if (this.value == 'Pause') {
          this.value = 'Play';
          if (nextFrameTimeout != null) {
            clearTimeout(nextFrameTimeout);
          }
        }
      }

      function nextFrame() {
        if (lastFrame >= frames.length) {
          controlButton.value = 'Replay';
          return;
        }

        var img = new Image();
        img.onload = function(e) {
          ctx.drawImage(img, 0, 0);
          lastFrame++;
          nextFrameTimeout = setTimeout(nextFrame, 1000 / fps);

          URL.revokeObjectURL(this.src);
        };
        img.src = URL.createObjectURL(frames[lastFrame]);
      }
    </script>
  </body>
</html>
