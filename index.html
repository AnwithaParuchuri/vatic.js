<!doctype html>

<html lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>VATIC-JS: A pure Javascript video annotation tool</title>
    <style>
      .output { font-family: monospace; font-weight: bold; }

      .rectangle {
        border: 1px solid #FF0000;
        position: absolute;
        z-index: 3;
      }

      #doodle {
        position: relative;
        z-index: 2;
        width: 0px;
        height: 0px;
      }

      #canvas {
        position: absolute;
        z-index: 1;
      }
    </style>
  </head>
  <body>
    <h1>VATIC-JS: A pure Javascript video annotation tool</h1>

    <ol>
      <li>
        <p>This tool can be used to easily annotate a video, without having to install anything.</p>
        <p>Optical flow is used to track your annotations, so that have to do as little work as possible ;-)</p>
        <p>This tool works best in Chrome, and has also been successfully tested in Firefox.</p>
      </li>
      <li>
        <p>To start a new video annotation, select a video file: <input type="file" id="videoFile" accept="video/*" /></p>
        <p>To resume a previous annotation, select a frames zip archive: <input type="file" id="zipFile" accept=".zip" /></p>
        <p>Note: Keep the focus on the browser during the entire extraction process, or frames might be skipped.</p>
        <p class="output" id="videoDimensions"></p>
        <p class="output" id="extractionProgress"></p>
      </li>
      <li>
        <p>Download the extracted frames zip archive: <button id="downloadFrames">Get frames zip archive</button></p>
      </li>
      <li>
        <p>Optional: Load an existing <a href="http://web.mit.edu/vondrick/vatic/" target="new">VATIC</a>-compatible XML annotation file.</p>
        <p>This is useful for example if:</p>
        <ul>
          <li>You are resuming a previous annotation.</li>
          <li>You already have a first version of your automatic object detector, which you want to improve by manually correcting its errors.</li>
        </ul>
        <p>Note: Launch your object detector on the extracted frames rather than on the original video to avoid frame/annotation mismatches!</p>
      </li>
      <li>
        <p>Manually annotate the frame sequence:</p>
        <div id="doodle">
          <canvas id="canvas"></canvas>
        </div>
        <p><input type="button" id="control" /></p>
        <p><label for="speed">Speed multiplier: </label><input type="text" id="speed" value="1.00" size="4" /></p>
        <p>Tip: Zoom in with your browser to place the bounding boxes more accurately.</p>
      </li>
      <li>
        <p>Download the <a href="http://web.mit.edu/vondrick/vatic/" target="new">VATIC</a>-compatible XML annotations file.</p>
      </li>
    </ol>

    <script type="text/javascript" src="dist/compatibility.js"></script>
    <script type="text/javascript" src="dist/jszip.js"></script>
    <script type="text/javascript" src="dist/StreamSaver.js"></script>
    <script type="text/javascript" src="dist/polyfill.js"></script>
    <script type="text/javascript" src="dist/jsfeat.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/pouchdb/6.0.7/pouchdb.min.js"></script>
    <script type="text/javascript">
      let config = {
        // Should be higher than real FPS to not skip real frames
        // Hardcoded due to JS limitations
        fps: 30,

        // Low rate decreases the chance of losing frames with poor browser performances
        playbackRate: 0.4,

        imageMimeType: 'image/jpeg',
        imageExtension: '.jpg'
      };

      // Orchestration region

      let doodle = document.querySelector('#doodle');
      let canvas = document.querySelector('#canvas');
      let ctx = canvas.getContext('2d');
      let videoFile = document.querySelector('#videoFile');
      let zipFile = document.querySelector('#zipFile');
      let videoDimensionsElement = document.querySelector('#videoDimensions');
      let extractionProgressElement = document.querySelector('#extractionProgress');
      let downloadFramesButton = document.querySelector('#downloadFrames');
      let controlButton = document.querySelector('#control');
      let speedInput = document.querySelector('#speed');

      videoFile.addEventListener(
        'change',
        function() {
          if (this.files.length == 1) {
            extractFramesFromVideo(config, this.files[0]).then(function(r) {
              console.log('extraction from video ended! total frames = ' + r.totalFrames());
              r.getFrame(0).then(function(blob) { console.log('1st frame:'); console.log(blob); });
            });
          }
        },
        false);
      zipFile.addEventListener(
        'change',
        function() {
          if (this.files.length == 1) {
            extractFramesFromZip(config, this.files[0]).then(function(r) {
              console.log('extraction from zip ended! total frames = ' + r.totalFrames());
              r.getFrame(0).then(function(blob) { console.log('1st frame:'); console.log(blob); });
            });
          }
        },
        false);

      controlButton.addEventListener('click', controlClicked, false);
      downloadFramesButton.addEventListener('click', downloadFrames, false);

      // Initialize state
      extractionStarting(null, true);

      // Frame extraction region

      function extractionStarting(callback, isInitialization = false) {
        if (!isInitialization) {
          videoFile.disabled = true;
          zipFile.disabled = true;
        }

        resetControlButton();
        controlButton.disabled = true;
        downloadFramesButton.disabled = true;
      }

      function extractionFoundDimensions(width, height) {
        doodle.style.width = width + 'px';
        doodle.style.height = height + 'px';
        canvas.width = width;
        canvas.height = height;
        videoDimensionsElement.innerHTML = 'Video dimensions determined: ' + canvas.width + 'x' + canvas.height;

        initOpticalFlow(width, height);
      }

      function extractionProgressed(percentage, framesSoFar) {
        extractionProgressElement.innerHTML = (percentage * 100).toFixed(2) + ' % completed. ' + framesSoFar + ' frames extracted.';
      }

      function extractionCompleted() {
        extractionProgressElement.innerHTML = 'Extraction completed. ' + totalFrames + ' frames captured.';

        if (totalFrames > 0) {
          getFrame(0, function(blob) {
            let img = new Image();
            img.onload = function(e) {
              ctx.drawImage(img, 0, 0);
              URL.revokeObjectURL(this.src);
            };
            img.src = URL.createObjectURL(blob);
          });
        }

        videoFile.disabled = false;
        zipFile.disabled = false;
        controlButton.disabled = false;
        downloadFramesButton.disabled = false;
      }

      // Frame extraction region

      function extractFramesFromVideo(config, file) {
        let resolve = null;
        let db = null;
        let video = document.createElement('video');
        let totalFrames = 0;
        let processedFrames = 0;
        let lastApproxFrame = -1;
        let attachmentName = 'img' + config.imageExtension;

        return new Promise(
          function(_resolve, _) {
            resolve = _resolve;

            let dbName = 'vatic_js';
            db = new PouchDB(dbName).destroy().then(function() {
              db = new PouchDB(dbName);

              video.autoplay = false;
              video.muted = true;
              video.loop = false;
              let loadedmetadataEventName = 'loadedmetadata';
              video.addEventListener(
                loadedmetadataEventName,
                function onMetadataLoaded(e) {
                  video.removeEventListener(loadedmetadataEventName, onMetadataLoaded);
                  compatibility.requestAnimationFrame(onBrowserAnimationFrame);
                  extractionFoundDimensions(video.videoWidth, video.videoHeight);
                },
                false);
              video.src = URL.createObjectURL(file);
              video.playbackRate = config.playbackRate;
              video.play();
            });
          }
        );

        function onBrowserAnimationFrame() {
          if (video.ended) {
            if (processedFrames == totalFrames) {
              videoEnded();
            }
            return;
          }

          compatibility.requestAnimationFrame(onBrowserAnimationFrame);

          if (video.readyState !== video.HAVE_CURRENT_DATA &&
              video.readyState !== video.HAVE_FUTURE_DATA &&
              video.readyState !== video.HAVE_ENOUGH_DATA) {
            return;
          }

          extractionProgressed(video.currentTime / video.duration, processedFrames);

          let currentApproxFrame = Math.round(video.currentTime * config.fps);
          if (currentApproxFrame != lastApproxFrame) {
            lastApproxFrame = currentApproxFrame;
            let frameNumber = totalFrames;
            totalFrames++;

            ctx.drawImage(video, 0, 0); // FIXME: Global
            canvas.toBlob( // FIXME: Global
              function(blob) {
                db.putAttachment(frameNumber.toString(), attachmentName, blob, config.imageMimeType).then(function(doc) {
                  processedFrames++;
                  if (video.ended && processedFrames == totalFrames) {
                    videoEnded();
                  }
                });
              },
              config.imageMimeType);
          }
        }

        function videoEnded() {
          if (video.src != '') {
            URL.revokeObjectURL(video.src);
            video.src = '';

            resolve({
              totalFrames: function() { return totalFrames; },
              getFrame(frameNumber) {
                return db.getAttachment(frameNumber.toString(), attachmentName);
              }
            });
          }
        }
      }

      function extractFramesFromZip(config, file) {
        return new Promise(
          function(resolve, _) {
            JSZip.loadAsync(file)
                .then(function(zip) {
                  let totalFrames = 0;
                  for (var i = 0; ; i++) {
                    let file = zip.file(i + config.imageExtension);
                    if (file == null) {
                      totalFrames = i;
                      break;
                    }
                  }

                  resolve({
                    totalFrames: function() { return totalFrames; },
                    getFrame(frameNumber) {
                      return new Promise(
                        function (resolve, _) {
                          let file = zip.file(frameNumber + config.imageExtension);
                          file.async('arraybuffer')
                              .then(function(content) {
                                let blob = new Blob([ content ], {type: 'image/jpeg'});
                                resolve(blob);
                          });
                      });
                    }
                  });
            });
        });
      }

      // Download frames region

      function downloadFrames() {
        let zip = new JSZip();

        let processed = 0;
        for (let i = 0; i < totalFrames; i++) {
          getFrame(i, function(blob) {
            zip.file(i + '.jpg', blob);
            processed++;

            if (processed == totalFrames) {
              let writeStream = streamSaver.createWriteStream('extracted-frames.zip').getWriter();
              zip.generateInternalStream({type: 'uint8array', streamFiles: true})
                 .on('data', data => writeStream.write(data))
                 .on('end', () => writeStream.close())
                 .resume();
            }
          });
        }
      }

      // Playback region

      var lastFrame = 0;

      document.body.onkeyup = function(e) {
        if (e.keyCode == 32) {
          e.preventDefault();
          controlClicked();
        }
      }

      function controlClicked() {
        if (controlButton.disabled) {
          // Can happen when the spacebar is hit
          return;
        }

        if (controlButton.value == 'Play') {
          controlButton.value = 'Pause';
          nextFrame();
        } else if (controlButton.value == 'Replay') {
          controlButton.value = 'Pause';
          lastFrame = 0;
          nextFrame();
        } else if (controlButton.value == 'Pause') {
          controlButton.value = 'Play';
        }
      }

      function nextFrame() {
        if (lastFrame >= totalFrames) {
          controlButton.value = 'Replay';
          return;
        }

        if (controlButton.value != 'Pause') {
          return;
        }

        getFrame(lastFrame, function(blob) {
          var img = new Image();
          img.onload = function(e) {
            ctx.drawImage(img, 0, 0);

            trackOpticalFlow(lastFrame);

            lastFrame++;
            setTimeout(nextFrame, 1000 / (fps * parseFloat(speedInput.value)));

            URL.revokeObjectURL(this.src);
          };
          img.src = URL.createObjectURL(blob);
        });
      }

      function resetControlButton() {
        controlButton.value = 'Play';
        lastFrame = 0;
      }

      // Bounding box drawing region

      class TrackedObject {
        constructor(dom, left, top) {
          this.dom = dom;
          this.width = 0;
          this.height = 0;
          this.left = left;
          this.top = top;
          this.visible = true;
        }
      }

      var trackedObjects = [];

      initDraw(document.querySelector('#doodle'));

      var prev_img_pyr = new jsfeat.pyramid_t(3);
      var curr_img_pyr = new jsfeat.pyramid_t(3);

      function initOpticalFlow(width, height) {
        prev_img_pyr.allocate(width, height, jsfeat.U8_t | jsfeat.C1_t);
        curr_img_pyr.allocate(width, height, jsfeat.U8_t | jsfeat.C1_t);
      }

      function trackOpticalFlow(frameNumber) {
        // TODO: 1st frame?

        if (trackedObjects.length < 1) {
          return;
        }

        let point_count = 0;
        let point_status = new Uint8Array(320*176);
        let prev_xy = new Float32Array(320*176*2);
        let curr_xy = new Float32Array(320*176*2);

        for (let i = 0; i < trackedObjects.length; i++) {
          let trackedObject = trackedObjects[i];
          if (!trackedObject.visible) {
            continue;
          }

          for (let x = trackedObject.left; x < trackedObject.left + trackedObject.width; x += Math.max(1, Math.round(trackedObject.width / 10))) {
            for (let y = trackedObject.top; y < trackedObject.top + trackedObject.height; y += Math.max(1, Math.round(trackedObject.height / 10))) {
              prev_xy[point_count*2] = x;
              prev_xy[point_count*2 + 1] = y;
              point_count++;
            }
          }
        }

        let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        jsfeat.imgproc.grayscale(imageData.data, canvas.width, canvas.height, curr_img_pyr.data[0]);
        curr_img_pyr.build(curr_img_pyr.data[0], true);

        if (point_count > 0) {
          jsfeat.optical_flow_lk.track(prev_img_pyr, curr_img_pyr, prev_xy, curr_xy, point_count, 30, 30, point_status, 0.01, 0.001);
        }

        point_count = 0;
        for (let i = 0; i < trackedObjects.length; i++) {
          let trackedObject = trackedObjects[i];
          if (!trackedObject.visible) {
            continue;
          }

          let diffX = [];
          let diffY = [];
          for (let x = trackedObject.left; x < trackedObject.left + trackedObject.width; x += Math.max(1, Math.round(trackedObject.width / 10))) {
            for (let y = trackedObject.top; y < trackedObject.top + trackedObject.height; y += Math.max(1, Math.round(trackedObject.height / 10))) {
              if (point_status[point_count] == 1) {
                diffX.push(curr_xy[point_count*2] - prev_xy[point_count*2]);
                diffY.push(curr_xy[point_count*2 + 1] - prev_xy[point_count*2 + 1]);
              }
              point_count++;
            }
          }
          console.log('success ratio: ' + (diffX.length / (trackedObject.width * trackedObject.height) ).toFixed(2) + ', tracked pointed = ' + point_count);
          if (diffX.length > 0) {
            let medianX = jsfeat.math.median(diffX, 0, diffX.length - 1);
            let medianY = jsfeat.math.median(diffY, 0, diffY.length - 1);

            trackedObject.left += Math.round(medianX);
            trackedObject.top += Math.round(medianY);
            trackedObject.dom.style.left = trackedObject.left + 'px';
            trackedObject.dom.style.top = trackedObject.top + 'px';
          } else {
            console.log('no longer visible!');
            trackedObject.visible = false;
            trackedObject.dom.style.top = '-100px';
          }
        }

        var old = prev_img_pyr;
        prev_img_pyr = curr_img_pyr;
        curr_img_pyr = old; // Buffer re-use
      }

      function initDraw(canvas) {
        function setMousePosition(e) {
          var ev = e || window.event;
          if (ev.pageX) {
            mouse.x = ev.pageX;
            mouse.y = ev.pageY;
          } else if (ev.clientX) {
            mouse.x = ev.clientX;
            mouse.y = ev.clientY;
          }
          mouse.x -= canvas.offsetLeft;
          mouse.y -= canvas.offsetTop;
        }

        var mouse = {
          x: 0,
          y: 0,
          startX: 0,
          startY: 0
        };
        var newTrackedObject = null;

        canvas.onmousemove = function (e) {
          setMousePosition(e);
          if (newTrackedObject !== null) {
            newTrackedObject.width = Math.abs(mouse.x - mouse.startX);
            newTrackedObject.height = Math.abs(mouse.y - mouse.startY);
            newTrackedObject.left = (mouse.x - mouse.startX < 0) ? mouse.x : mouse.startX;
            newTrackedObject.top = (mouse.y - mouse.startY < 0) ? mouse.y : mouse.startY;

            newTrackedObject.dom.style.width = newTrackedObject.width + 'px';
            newTrackedObject.dom.style.height = newTrackedObject.height + 'px';
            newTrackedObject.dom.style.left = newTrackedObject.left + 'px';
            newTrackedObject.dom.style.top = newTrackedObject.top + 'px';
          }
        }

        canvas.onclick = function (e) {
          if (newTrackedObject !== null) {
            trackedObjects.push(newTrackedObject);
            newTrackedObject = null;
            canvas.style.cursor = 'default';
          } else {
            mouse.startX = mouse.x;
            mouse.startY = mouse.y;
            dom = document.createElement('div');
            dom.className = 'rectangle';
            dom.style.left = mouse.x + 'px';
            dom.style.top = mouse.y + 'px';
            canvas.appendChild(dom);
            newTrackedObject = new TrackedObject(dom, mouse.x, mouse.y);
            canvas.style.cursor = 'crosshair';
          }
        }
      }
    </script>
  </body>
</html>
