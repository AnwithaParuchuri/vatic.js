<!doctype html>

<html lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>VATIC-JS: A pure Javascript video annotating tool</title>
    <style>
      .output { font-family: monospace; }
    </style>
  </head>
  <body>
    <video id="video" style="display: none;"></video>

    <h1>VATIC-JS: A pure Javascript video annotating tool</h1>

    <ol>
      <li>
        <p>This tool can be used to easily annotate a video, without having to install anything.</p>
        <p>Optical flow is used to track your annotations, so that have to do as little work as possible ;-)</p>
        <p>This tool works best in Chrome, and has also been successfully tested in Firefox.</p>
      </li>
      <li>
        <p>To start a new video annotation, select a video file. <input type="file" id="video_file" accept="video/*" /></p>
        <p>To resume a previous annotation, select a frames zip archive. <input type="file" id="zip_file" accept=".zip" /></p>
        <p>NOTE: Keep the focus on the browser during the entire extraction process, or frames might be skipped.</p>
        <p class="output" id="video_dimensions"></p>
        <p class="output" id="extraction_progress"></p>
      </li>
      <li>
        <p>Download the extracted frames zip archive.</p>
      </li>
      <li>
        <p>Optional: Load an existing <a href="http://web.mit.edu/vondrick/vatic/" target="new">VATIC</a>-compatible XML annotation file.</p>
        <p>This is useful for example if:</p>
        <ul>
          <li>You are resuming a previous annotation.</li>
          <li>You already have a first version of your automatic object detector, which you want to improve by manually correcting its errors.</li>
        </ul>
      </li>
      <li>
        <p>Manually annotate the frames.</p>
        <canvas id="canvas"></canvas>
        <br />
        <button id="play">Play</button>
      </li>
      <li>
        <p>Download the <a href="http://web.mit.edu/vondrick/vatic/" target="new">VATIC</a>-compatible XML annotations file.</p>
      </li>
    </ol>

    <script type="text/javascript" src="compatibility.js"></script>
    <script type="text/javascript">
      // Should be higher than real FPS to not skip real frames
      // Hardcoded due to JS limitations
      var fps = 30;

      // Low rate decreases the chance of losing frames with poor browser performances
      var playbackRate = 0.4;

      var video = document.querySelector('#video');
      var canvas = document.querySelector('#canvas');
      var ctx = canvas.getContext('2d');
      var video_dimensions = document.querySelector('#video_dimensions');
      var extraction_progress = document.querySelector('#extraction_progress');

      var frames = [];
      var lastFrame = -1;

      document.querySelector('input').addEventListener('change', extractFrames, false);
      document.querySelector('#play').addEventListener('click', replay, false);

      function extractFrames() {
        if (this.files.length == 0) {
          return;
        }

        frames = [];
        lastFrame = -1;
        var inflight = 0;

        function initCanvas(e) {
          video.removeEventListener('loadedmetadata', initCanvas);

          canvas.width = this.videoWidth;
          canvas.height = this.videoHeight;
          video_dimensions.innerHTML = 'Video dimensions determined: ' + canvas.width + 'x' + canvas.height;

          compatibility.requestAnimationFrame(drawFrame);
        }

        function drawFrame() {
          if (video.ended) {
            if (frames.length == inflight) {
              ended();
            }
            return;
          }

          compatibility.requestAnimationFrame(drawFrame);

          if (video.readyState !== video.HAVE_CURRENT_DATA &&
              video.readyState !== video.HAVE_FUTURE_DATA &&
              video.readyState !== video.HAVE_ENOUGH_DATA) {
            return;
          }

          extraction_progress.innerHTML = ((video.currentTime / video.duration) * 100).toFixed(2) + ' % completed. ' + frames.length + ' frames extracted. ';

          var currentFrame = Math.round(video.currentTime * fps);
          if (currentFrame != lastFrame) {
            lastFrame = currentFrame;
            inflight++;
            ctx.drawImage(video, 0, 0);
            canvas.toBlob(saveFrame, 'image/jpeg');
          }
        }

        function saveFrame(blob) {
          img = new Image();
          img.onload = revokeURL;
          img.src = URL.createObjectURL(blob);
          frames.push(img);

          if (video.ended && frames.length == inflight) {
            ended();
          }
        }

        function ended() {
          if (video.src != '') {
            extraction_progress.innerHTML = 'Extraction completed. ' + frames.length + ' frames captured.';
            URL.revokeObjectURL(video.src);
            video.src = '';
          }
        }

        function revokeURL(e) {
          URL.revokeObjectURL(this.src);
        }

        video.autoplay = false;
        video.muted = true;
        video.loop = false;
        video.addEventListener('loadedmetadata', initCanvas, false);
        video.src = URL.createObjectURL(this.files[0]);
        video.playbackRate = playbackRate;
        video.play();
      }

      function replay() {
        lastFrame = 0;
        nextFrame();
      }

      function nextFrame() {
        if (lastFrame < 0 || lastFrame >= frames.length) {
          return;
        }

        ctx.drawImage(frames[lastFrame], 0, 0);
        lastFrame++;
        setTimeout(nextFrame, 1000 / fps);
      }
    </script>
  </body>
</html>
