<!doctype html>

<html lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>VATIC-JS: A pure Javascript video annotation tool</title>
    <style>
      .output { font-family: monospace; font-weight: bold; }

      .rectangle {
        border: 1px solid #FF0000;
        position: absolute;
        z-index: 3;
      }

      #doodle {
        position: relative;
        z-index: 2;
        width: 0px;
        height: 0px;
      }

      #canvas {
        position: absolute;
        z-index: 1;
      }
    </style>
  </head>
  <body>
    <video id="video" style="display: none;"></video>

    <h1>VATIC-JS: A pure Javascript video annotation tool</h1>

    <ol>
      <li>
        <p>This tool can be used to easily annotate a video, without having to install anything.</p>
        <p>Optical flow is used to track your annotations, so that have to do as little work as possible ;-)</p>
        <p>This tool works best in Chrome, and has also been successfully tested in Firefox.</p>
      </li>
      <li>
        <p>To start a new video annotation, select a video file: <input type="file" id="videoFile" accept="video/*" /></p>
        <p>To resume a previous annotation, select a frames zip archive: <input type="file" id="zipFile" accept=".zip" /></p>
        <p>Note: Keep the focus on the browser during the entire extraction process, or frames might be skipped.</p>
        <p class="output" id="videoDimensions"></p>
        <p class="output" id="extractionProgress"></p>
      </li>
      <li>
        <p>Download the extracted frames zip archive: <button id="downloadFrames">Get frames zip archive</button></p>
      </li>
      <li>
        <p>Optional: Load an existing <a href="http://web.mit.edu/vondrick/vatic/" target="new">VATIC</a>-compatible XML annotation file.</p>
        <p>This is useful for example if:</p>
        <ul>
          <li>You are resuming a previous annotation.</li>
          <li>You already have a first version of your automatic object detector, which you want to improve by manually correcting its errors.</li>
        </ul>
        <p>Note: Launch your object detector on the extracted frames rather than on the original video to avoid frame/annotation mismatches!</p>
      </li>
      <li>
        <p>Manually annotate the frame sequence:</p>
        <div id="doodle">
          <canvas id="canvas"></canvas>
        </div>
        <p><input type="button" id="control" /></p>
        <p><label for="speed">Speed multiplier: </label><input type="text" id="speed" value="1.00" size="4" /></p>
        <p>Tip: Zoom in with your browser to place the bounding boxes more accurately.</p>
      </li>
      <li>
        <p>Download the <a href="http://web.mit.edu/vondrick/vatic/" target="new">VATIC</a>-compatible XML annotations file.</p>
      </li>
    </ol>

    <script type="text/javascript" src="dist/compatibility.js"></script>
    <script type="text/javascript" src="dist/jszip.js"></script>
    <script type="text/javascript" src="dist/StreamSaver.js"></script>
    <script type="text/javascript" src="dist/polyfill.js"></script>
    <script type="text/javascript" src="dist/jsfeat.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/pouchdb/6.0.7/pouchdb.min.js"></script>
    <script type="text/javascript">
      // Should be higher than real FPS to not skip real frames
      // Hardcoded due to JS limitations
      var fps = 30;

      // Low rate decreases the chance of losing frames with poor browser performances
      var playbackRate = 0.4;

      var video = document.querySelector('#video');
      var doodle = document.querySelector('#doodle');
      var canvas = document.querySelector('#canvas');
      var ctx = canvas.getContext('2d');
      var videoFile = document.querySelector('#videoFile');
      var zipFile = document.querySelector('#zipFile');
      var videoDimensionsElement = document.querySelector('#videoDimensions');
      var extractionProgressElement = document.querySelector('#extractionProgress');
      var downloadFramesButton = document.querySelector('#downloadFrames');
      var controlButton = document.querySelector('#control');
      var speedInput = document.querySelector('#speed');

      videoFile.addEventListener('change', extractFramesFromVideo, false);
      zipFile.addEventListener('change', extractFramesFromArchive, false);

      controlButton.addEventListener('click', controlClicked, false);
      downloadFramesButton.addEventListener('click', downloadFrames, false);

      // Frames handling
      var db = null;
      var totalFrames = 0;

      function addFrame(frameNumber, blob, callback) {
        totalFrames++;
        return db.putAttachment(frameNumber.toString(), 'img.jpg', blob, 'image/jpeg').then(function(doc) { callback(); });
      }

      function getFrame(frameNumber, callback) {
        db.getAttachment(frameNumber.toString(), 'img.jpg').then(function(blob) { callback(blob); });
      }

      // Initialize state
      extractionStarting(null, true);

      // Frame extraction region

      function extractionStarting(callback, isInitialization = false) {
        if (!isInitialization) {
          videoFile.disabled = true;
          zipFile.disabled = true;
        }

        db = new PouchDB('vatic_js').destroy().then(function() {
          db = new PouchDB('vatic_js');
          totalFrames = 0;

          resetControlButton();
          controlButton.disabled = true;
          downloadFramesButton.disabled = true;

          if (callback != null) {
            callback();
          }
        });
      }

      function extractionFoundDimensions(width, height) {
        doodle.style.width = width + 'px';
        doodle.style.height = height + 'px';
        canvas.width = width;
        canvas.height = height;
        videoDimensionsElement.innerHTML = 'Video dimensions determined: ' + canvas.width + 'x' + canvas.height;

        initOpticalFlow(width, height);
      }

      function extractionProgressed(percentage, framesSoFar) {
        extractionProgressElement.innerHTML = (percentage * 100).toFixed(2) + ' % completed. ' + framesSoFar + ' frames extracted.';
      }

      function extractionCompleted() {
        extractionProgressElement.innerHTML = 'Extraction completed. ' + totalFrames + ' frames captured.';

        if (totalFrames > 0) {
          getFrame(0, function(blob) {
            let img = new Image();
            img.onload = function(e) {
              ctx.drawImage(img, 0, 0);
              URL.revokeObjectURL(this.src);
            };
            img.src = URL.createObjectURL(blob);
          });
        }

        videoFile.disabled = false;
        zipFile.disabled = false;
        controlButton.disabled = false;
        downloadFramesButton.disabled = false;
      }

      function extractFramesFromVideo() {
        function onBrowserAnimationFrame() {
          if (video.ended) {
            if (processed == frameCounter) {
              ended();
            }
            return;
          }

          compatibility.requestAnimationFrame(onBrowserAnimationFrame);

          if (video.readyState !== video.HAVE_CURRENT_DATA &&
              video.readyState !== video.HAVE_FUTURE_DATA &&
              video.readyState !== video.HAVE_ENOUGH_DATA) {
            return;
          }

          extractionProgressed(video.currentTime / video.duration, processed);

          var currentApproxFrame = Math.round(video.currentTime * fps);
          if (currentApproxFrame != lastApproxFrame) {
            lastApproxFrame = currentApproxFrame;
            frameCounter++;

            var _ = function(frameNumber) {
              ctx.drawImage(video, 0, 0);
              canvas.toBlob(
                function(blob) {
                  addFrame(frameNumber, blob, function() {
                    processed++;
                    if (video.ended && processed == frameCounter) {
                      ended();
                    }
                  });
                },
                'image/jpeg');
            }(frameCounter - 1);
          }
        }

        function ended() {
          if (video.src != '') {
            URL.revokeObjectURL(video.src);
            video.src = '';
            extractionCompleted();
          }
        }

        if (this.files.length == 0) {
          return;
        }

        var lastApproxFrame = -1;
        var frameCounter = 0;
        var processed = 0;

        extractionStarting(function() {
          video.autoplay = false;
          video.muted = true;
          video.loop = false;
          video.addEventListener(
            'loadedmetadata',
            function onMetadata(e) {
              video.removeEventListener('loadedmetadata', onMetadata);
              compatibility.requestAnimationFrame(onBrowserAnimationFrame);
              extractionFoundDimensions(video.videoWidth, video.videoHeight);
            },
            false);
          video.src = URL.createObjectURL(videoFile.files[0]);
          video.playbackRate = playbackRate;
          video.play();
        });
      }

      function extractFramesFromArchive() {
        if (this.files.length == 0) {
          return;
        }

        extractionStarting(function() {
          JSZip.loadAsync(zipFile.files[0])
              .then(function(zip) {
                var total = 0;
                for (var i = 0; ; i++) {
                  var frame = zip.file(i + '.jpg');
                  if (frame == null) {
                    total = i;
                    break;
                  }
                }

                var processed = 0;
                for (var i = 0; i < total; i++) {
                  var _ = function (frameNumber) {
                    var frame = zip.file(frameNumber + '.jpg');
                    frame.async('arraybuffer')
                          .then(function(content) {
                            let blob = new Blob([ content ], {type: 'image/jpeg'});

                            if (frameNumber == 0) {
                              let img = new Image();
                              img.onload = function(e) {
                                extractionFoundDimensions(this.width, this.height);
                                URL.revokeObjectURL(this.src);
                              };
                              img.src = URL.createObjectURL(blob);
                            }

                            addFrame(frameNumber, blob, function() {
                              processed++;
                              extractionProgressed(processed / total, processed);
                              if (processed == total) {
                                extractionCompleted();
                              }
                            });
                          });
                  }(i);
                }
              });
        });
      }

      // Download frames region

      function downloadFrames() {
        var zip = new JSZip();

        for (var i = 0; i < frames.length; i++) {
          zip.file(i + '.jpg', frames[i]);
        }

        let writeStream = streamSaver.createWriteStream('extracted-frames.zip').getWriter();
        zip.generateInternalStream({type: 'uint8array', streamFiles: true})
           .on('data', data => writeStream.write(data))
           .on('error', err => console.error(err))
           .on('end', () => writeStream.close())
           .resume();
      }

      // Playback region

      var lastFrame = 0;

      document.body.onkeyup = function(e) {
        if (e.keyCode == 32) {
          e.preventDefault();
          controlClicked();
        }
      }

      function controlClicked() {
        if (controlButton.disabled) {
          // Can happen when the spacebar is hit
          return;
        }

        if (controlButton.value == 'Play') {
          controlButton.value = 'Pause';
          nextFrame();
        } else if (controlButton.value == 'Replay') {
          controlButton.value = 'Pause';
          lastFrame = 0;
          nextFrame();
        } else if (controlButton.value == 'Pause') {
          controlButton.value = 'Play';
        }
      }

      function nextFrame() {
        if (lastFrame >= totalFrames) {
          controlButton.value = 'Replay';
          return;
        }

        if (controlButton.value != 'Pause') {
          return;
        }

        getFrame(lastFrame, function(blob) {
          var img = new Image();
          img.onload = function(e) {
            ctx.drawImage(img, 0, 0);

            trackOpticalFlow(lastFrame);

            lastFrame++;
            setTimeout(nextFrame, 1000 / (fps * parseFloat(speedInput.value)));

            URL.revokeObjectURL(this.src);
          };
          img.src = URL.createObjectURL(blob);
        });
      }

      function resetControlButton() {
        controlButton.value = 'Play';
        lastFrame = 0;
      }

      // Bounding box drawing region

      class TrackedObject {
        constructor(dom, left, top) {
          this.dom = dom;
          this.width = 0;
          this.height = 0;
          this.left = left;
          this.top = top;
          this.visible = true;
        }
      }

      var trackedObjects = [];

      initDraw(document.querySelector('#doodle'));

      var prev_img_pyr = new jsfeat.pyramid_t(3);
      var curr_img_pyr = new jsfeat.pyramid_t(3);

      function initOpticalFlow(width, height) {
        prev_img_pyr.allocate(width, height, jsfeat.U8_t | jsfeat.C1_t);
        curr_img_pyr.allocate(width, height, jsfeat.U8_t | jsfeat.C1_t);
      }

      function trackOpticalFlow(frameNumber) {
        // TODO: 1st frame?

        if (trackedObjects.length < 1) {
          return;
        }

        let point_count = 0;
        let point_status = new Uint8Array(320*176);
        let prev_xy = new Float32Array(320*176*2);
        let curr_xy = new Float32Array(320*176*2);

        for (let i = 0; i < trackedObjects.length; i++) {
          let trackedObject = trackedObjects[i];
          if (!trackedObject.visible) {
            continue;
          }

          for (let x = trackedObject.left; x < trackedObject.left + trackedObject.width; x += Math.max(1, Math.round(trackedObject.width / 10))) {
            for (let y = trackedObject.top; y < trackedObject.top + trackedObject.height; y += Math.max(1, Math.round(trackedObject.height / 10))) {
              prev_xy[point_count*2] = x;
              prev_xy[point_count*2 + 1] = y;
              point_count++;
            }
          }
        }

        let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        jsfeat.imgproc.grayscale(imageData.data, canvas.width, canvas.height, curr_img_pyr.data[0]);
        curr_img_pyr.build(curr_img_pyr.data[0], true);

        if (point_count > 0) {
          jsfeat.optical_flow_lk.track(prev_img_pyr, curr_img_pyr, prev_xy, curr_xy, point_count, 30, 30, point_status, 0.01, 0.001);
        }

        point_count = 0;
        for (let i = 0; i < trackedObjects.length; i++) {
          let trackedObject = trackedObjects[i];
          if (!trackedObject.visible) {
            continue;
          }

          let diffX = [];
          let diffY = [];
          for (let x = trackedObject.left; x < trackedObject.left + trackedObject.width; x += Math.max(1, Math.round(trackedObject.width / 10))) {
            for (let y = trackedObject.top; y < trackedObject.top + trackedObject.height; y += Math.max(1, Math.round(trackedObject.height / 10))) {
              if (point_status[point_count] == 1) {
                diffX.push(curr_xy[point_count*2] - prev_xy[point_count*2]);
                diffY.push(curr_xy[point_count*2 + 1] - prev_xy[point_count*2 + 1]);
              }
              point_count++;
            }
          }
          console.log('success ratio: ' + (diffX.length / (trackedObject.width * trackedObject.height) ).toFixed(2) + ', tracked pointed = ' + point_count);
          if (diffX.length > 0) {
            let medianX = jsfeat.math.median(diffX, 0, diffX.length - 1);
            let medianY = jsfeat.math.median(diffY, 0, diffY.length - 1);

            trackedObject.left += Math.round(medianX);
            trackedObject.top += Math.round(medianY);
            trackedObject.dom.style.left = trackedObject.left + 'px';
            trackedObject.dom.style.top = trackedObject.top + 'px';
          } else {
            console.log('no longer visible!');
            trackedObject.visible = false;
            trackedObject.dom.style.top = '-100px';
          }
        }

        var old = prev_img_pyr;
        prev_img_pyr = curr_img_pyr;
        curr_img_pyr = old; // Buffer re-use
      }

      function initDraw(canvas) {
        function setMousePosition(e) {
          var ev = e || window.event;
          if (ev.pageX) {
            mouse.x = ev.pageX;
            mouse.y = ev.pageY;
          } else if (ev.clientX) {
            mouse.x = ev.clientX;
            mouse.y = ev.clientY;
          }
          mouse.x -= canvas.offsetLeft;
          mouse.y -= canvas.offsetTop;
        }

        var mouse = {
          x: 0,
          y: 0,
          startX: 0,
          startY: 0
        };
        var newTrackedObject = null;

        canvas.onmousemove = function (e) {
          setMousePosition(e);
          if (newTrackedObject !== null) {
            newTrackedObject.width = Math.abs(mouse.x - mouse.startX);
            newTrackedObject.height = Math.abs(mouse.y - mouse.startY);
            newTrackedObject.left = (mouse.x - mouse.startX < 0) ? mouse.x : mouse.startX;
            newTrackedObject.top = (mouse.y - mouse.startY < 0) ? mouse.y : mouse.startY;

            newTrackedObject.dom.style.width = newTrackedObject.width + 'px';
            newTrackedObject.dom.style.height = newTrackedObject.height + 'px';
            newTrackedObject.dom.style.left = newTrackedObject.left + 'px';
            newTrackedObject.dom.style.top = newTrackedObject.top + 'px';
          }
        }

        canvas.onclick = function (e) {
          if (newTrackedObject !== null) {
            trackedObjects.push(newTrackedObject);
            newTrackedObject = null;
            canvas.style.cursor = 'default';
          } else {
            mouse.startX = mouse.x;
            mouse.startY = mouse.y;
            dom = document.createElement('div');
            dom.className = 'rectangle';
            dom.style.left = mouse.x + 'px';
            dom.style.top = mouse.y + 'px';
            canvas.appendChild(dom);
            newTrackedObject = new TrackedObject(dom, mouse.x, mouse.y);
            canvas.style.cursor = 'crosshair';
          }
        }
      }
    </script>
  </body>
</html>
