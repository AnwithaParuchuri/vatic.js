<!doctype html>

<html lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>VATIC-JS: A pure Javascript video annotation tool</title>
    <style>
      .output { font-family: monospace; font-weight: bold; }

      .rectangle {
        border: 1px solid #FF0000;
        position: absolute;
        z-index: 3;
      }

      #doodle {
        position: relative;
        z-index: 2;
        width: 0px;
        height: 0px;
      }

      #canvas {
        position: absolute;
        z-index: 1;
      }
    </style>
  </head>
  <body>
    <h1>VATIC-JS: A pure Javascript video annotation tool</h1>

    <ol>
      <li>
        <p>This tool can be used to easily annotate a video, without having to install anything.</p>
        <p>Optical flow is used to track your annotations, so that have to do as little work as possible ;-)</p>
        <p>This tool works best in Chrome, and has also been successfully tested in Firefox.</p>
      </li>
      <li>
        <p>To start a new video annotation, select a video file: <input type="file" id="videoFile" accept="video/*" /></p>
        <p>To resume a previous annotation, select a frames zip archive: <input type="file" id="zipFile" accept=".zip" /></p>
        <p>Note: Keep the focus on the browser during the entire extraction process, or frames might be skipped.</p>
        <p class="output" id="videoDimensions"></p>
        <p class="output" id="extractionProgress"></p>
      </li>
      <li>
        <p>Download the extracted frames zip archive: <input type="button" id="downloadFrames" value="Get frames zip archive" disabled="disabled" /></p>
      </li>
      <li>
        <p>Optional: Load an existing <a href="http://web.mit.edu/vondrick/vatic/" target="new">VATIC</a>-compatible XML annotation file.</p>
        <p>This is useful for example if:</p>
        <ul>
          <li>You are resuming a previous annotation.</li>
          <li>You already have a first version of your automatic object detector, which you want to improve by manually correcting its errors.</li>
        </ul>
        <p>Note: Launch your object detector on the extracted frames rather than on the original video to avoid frame/annotation mismatches!</p>
      </li>
      <li>
        <p>Manually annotate the frame sequence:</p>
        <div id="doodle">
          <canvas id="canvas"></canvas>
        </div>
        <p><input type="button" id="play" value="Play" disabled="true" /><input type="button" id="pause" value="Pause" disabled="true" style="display: none;" /></p>
        <p><label for="speed">Speed multiplier: </label><input type="text" id="speed" value="1.00" size="4" /></p>
        <p>Tip: Zoom in with your browser to place the bounding boxes more accurately.</p>
      </li>
      <li>
        <p>Download the <a href="http://web.mit.edu/vondrick/vatic/" target="new">VATIC</a>-compatible XML annotations file.</p>
      </li>
    </ol>

    <script type="text/javascript" src="dist/compatibility.js"></script>
    <script type="text/javascript" src="dist/jszip.js"></script>
    <script type="text/javascript" src="dist/StreamSaver.js"></script>
    <script type="text/javascript" src="dist/polyfill.js"></script>
    <script type="text/javascript" src="dist/jsfeat.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/pouchdb/6.0.7/pouchdb.min.js"></script>
    <script type="text/javascript">
      "use strict";

      let config = {
        // Should be higher than real FPS to not skip real frames
        // Hardcoded due to JS limitations
        fps: 30,

        // Low rate decreases the chance of losing frames with poor browser performances
        playbackRate: 0.4,

        // Format of the extracted frames
        imageMimeType: 'image/jpeg',
        imageExtension: '.jpg',

        // Name of the extracted frames zip archive
        framesZipFilename: 'extracted-frames.zip'
      };

      // Orchestration region

      let doodle = document.querySelector('#doodle');
      let canvas = document.querySelector('#canvas');
      let ctx = canvas.getContext('2d');
      let videoFile = document.querySelector('#videoFile');
      let zipFile = document.querySelector('#zipFile');
      let videoDimensionsElement = document.querySelector('#videoDimensions');
      let extractionProgressElement = document.querySelector('#extractionProgress');
      let downloadFramesButton = document.querySelector('#downloadFrames');
      let playButton = document.querySelector('#play');
      let pauseButton = document.querySelector('#pause');
      let speedInput = document.querySelector('#speed');

      let player = {
        currentFrame: 0,
        isPlaying: false,
        isReady: false,
        timeout: null,

        initialize: function() {
          this.currentFrame = 0;
          this.isPlaying = false;
          this.isReady = false;

          playButton.disabled = true;
          playButton.style.display = 'block';
          pauseButton.disabled = true;
          pauseButton.style.display = 'none';
        },

        ready: function() {
          this.isReady = true;

          playButton.disabled = false;
        },

        play: function() {
          if (!this.isReady) {
            return;
          }

          this.isPlaying = true;

          playButton.disabled = true;
          playButton.style.display = 'none';
          pauseButton.disabled = false;
          pauseButton.style.display = 'block';

          this.nextFrame();
        },

        pause: function() {
          if (!this.isReady) {
            return;
          }

          this.isPlaying = false;
          if (this.timeout != null) {
            clearTimeout(this.timeout);
            this.timeout = null;
          }

          pauseButton.disabled = true;
          pauseButton.style.display = 'none';
          playButton.disabled = false;
          playButton.style.display = 'block';
        },

        toogle: function() {
          if (!this.isPlaying) {
            this.play();
          } else {
            this.pause();
          }
        },

        nextFrame: function() {
          if (!this.isPlaying) {
            return;
          }

          if (this.currentFrame >= orchestrator.frames.totalFrames()) {
            this.done();
            return;
          }

          orchestrator.getFrameWithObjects(this.currentFrame).then((img) => {
            if (!this.isPlaying) {
              return;
            }

            ctx.drawImage(img, 0, 0);

            this.currentFrame++;
            this.timeout = setTimeout(() => this.nextFrame(), 1000 / (config.fps * parseFloat(speedInput.value)));
          });
        },

        done: function() {
          this.currentFrame = 0;
          this.isPlaying = false;

          playButton.disabled = false;
          playButton.style.display = 'block';
          pauseButton.disabled = true;
          pauseButton.style.display = 'none';
        }
      };

      videoFile.addEventListener('change', extractionFileUploaded, false);
      zipFile.addEventListener('change', extractionFileUploaded, false);
      playButton.addEventListener('click', playClicked, false);
      pauseButton.addEventListener('click', pauseClicked, false);
      downloadFramesButton.addEventListener('click', downloadFrames, false);
      document.body.onkeyup = function(e) {
        if (e.keyCode == 32) {
          e.preventDefault();
          player.toogle();
        }
      }

      function playClicked() {
        player.play();
      }

      function pauseClicked() {
        player.pause();
      }

      function downloadFrames() {
        let zip = new JSZip();

        let processed = 0;
        let totalFrames = orchestrator.frames.totalFrames();
        for (let i = 0; i < totalFrames; i++) {
          orchestrator.frames.getFrame(i).then((blob) => {
            zip.file(i + '.jpg', blob);

            processed++;
            if (processed == totalFrames) {
              let writeStream = streamSaver.createWriteStream('extracted-frames.zip').getWriter();
              zip.generateInternalStream({type: 'uint8array', streamFiles: true})
                 .on('data', data => writeStream.write(data))
                 .on('end', () => writeStream.close())
                 .resume();
            }
          });
        }
      }

      function blobToImage(blob) {
        return new Promise((result, _) => {
          let img = new Image();
          img.onload = function() {
            result(img);
            URL.revokeObjectURL(this.src);
          };
          img.src = URL.createObjectURL(blob);
        });
      }

      function initializeCanvasDimensions(img) {
        doodle.style.width = img.width + 'px';
        doodle.style.height = img.height + 'px';
        canvas.width = img.width;
        canvas.height = img.height;
      }

      function extractionFileUploaded() {
        if (this.files.length != 1) {
          return;
        }

        videoFile.disabled = true;
        zipFile.disabled = true;
        downloadFramesButton.disabled = true;
        player.initialize();

        let promise;
        if (this == videoFile) {
          let dimensionsInitialized = false;

          promise = extractFramesFromVideo(
            config,
            this.files[0],
            (percentage, framesSoFar, lastFrameBlob) => {
              blobToImage(lastFrameBlob).then((img) => {
                if (!dimensionsInitialized) {
                  dimensionsInitialized = true;
                  initializeCanvasDimensions(img);
                }
                ctx.drawImage(img, 0, 0);

                videoDimensionsElement.innerHTML = 'Video dimensions determined: ' + img.width + 'x' + img.height;
                extractionProgressElement.innerHTML = (percentage * 100).toFixed(2) + ' % completed. ' + framesSoFar + ' frames extracted.';
              });
            });
        } else {
          promise = extractFramesFromZip(config, this.files[0]);
        }

        promise.then((_frames) => {
          extractionProgressElement.innerHTML = 'Extraction completed. ' + _frames.totalFrames() + ' frames captured.';
          if (_frames.totalFrames() > 0) {
            _frames.getFrame(0).then((blob) => {
              blobToImage(blob).then((img) => {
                initializeCanvasDimensions(img);
                ctx.drawImage(img, 0, 0);
                videoDimensionsElement.innerHTML = 'Video dimensions determined: ' + img.width + 'x' + img.height;

                orchestrator.frames = _frames;
                player.ready();

                playButton.disabled = false;
                downloadFramesButton.disabled = false;
              });
            });
          }

          videoFile.disabled = false;
          zipFile.disabled = false;
        });
      }

      // Frame extraction region

      function extractFramesFromVideo(config, file, progress) {
        let resolve = null;
        let db = null;
        let video = document.createElement('video');
        let canvas = document.createElement('canvas');
        let ctx = canvas.getContext('2d');
        let dimensionsInitialized = false;
        let totalFrames = 0;
        let processedFrames = 0;
        let lastApproxFrame = -1;
        let attachmentName = 'img' + config.imageExtension;

        return new Promise((_resolve, _) => {
          resolve = _resolve;

          let dbName = 'vatic_js';
          db = new PouchDB(dbName).destroy().then(() => {
            db = new PouchDB(dbName);

            video.autoplay = false;
            video.muted = true;
            video.loop = false;
            video.playbackRate = config.playbackRate;
            video.src = URL.createObjectURL(file);
            compatibility.requestAnimationFrame(onBrowserAnimationFrame);
            video.play();
          });
        });

        function onBrowserAnimationFrame() {
          if (dimensionsInitialized && video.ended) {
            if (processedFrames == totalFrames) {
              videoEnded();
            }
            return;
          }

          compatibility.requestAnimationFrame(onBrowserAnimationFrame);

          if (video.readyState !== video.HAVE_CURRENT_DATA &&
              video.readyState !== video.HAVE_FUTURE_DATA &&
              video.readyState !== video.HAVE_ENOUGH_DATA) {
            return;
          }

          let currentApproxFrame = Math.round(video.currentTime * config.fps);
          if (currentApproxFrame != lastApproxFrame) {
            lastApproxFrame = currentApproxFrame;
            let frameNumber = totalFrames;
            totalFrames++;

            if (!dimensionsInitialized) {
              dimensionsInitialized = true;
              canvas.width = video.videoWidth;
              canvas.height = video.videoHeight;
            }

            ctx.drawImage(video, 0, 0);
            canvas.toBlob(
              (blob) => {
                db.putAttachment(frameNumber.toString(), attachmentName, blob, config.imageMimeType).then((doc) => {
                  processedFrames++;

                  progress(video.currentTime / video.duration, processedFrames, blob);

                  if (video.ended && processedFrames == totalFrames) {
                    videoEnded();
                  }
                });
              },
              config.imageMimeType);
          }
        }

        function videoEnded() {
          if (video.src != '') {
            URL.revokeObjectURL(video.src);
            video.src = '';

            resolve({
              totalFrames: () => { return totalFrames; },
              getFrame: (frameNumber) => {
                return db.getAttachment(frameNumber.toString(), attachmentName);
              }
            });
          }
        }
      }

      function extractFramesFromZip(config, file) {
        return new Promise((resolve, _) => {
          JSZip
            .loadAsync(file)
            .then((zip) => {
              let totalFrames = 0;
              for (let i = 0; ; i++) {
                let file = zip.file(i + config.imageExtension);
                if (file == null) {
                  totalFrames = i;
                  break;
                }
              }

              resolve({
                totalFrames: () => { return totalFrames; },
                getFrame: (frameNumber) => {
                  return new Promise((resolve, _) => {
                    let file = zip.file(frameNumber + config.imageExtension);
                    file
                      .async('arraybuffer')
                      .then((content) => {
                        let blob = new Blob([ content ], {type: config.imageMimeType});
                        resolve(blob);
                      });
                  });
                }
              });
            });
        });
      }

      // Optical flow tracking region

      class OpticalFlow {
        constructor() {
          this.isInitialized = false;
          this.previousPyramid = new jsfeat.pyramid_t(3);
          this.currentPyramid = new jsfeat.pyramid_t(3);
        }

        init(imageData) {
          this.previousPyramid.allocate(imageData.width, imageData.height, jsfeat.U8_t | jsfeat.C1_t);
          this.currentPyramid.allocate(imageData.width, imageData.height, jsfeat.U8_t | jsfeat.C1_t);
          jsfeat.imgproc.grayscale(imageData.data, imageData.width, imageData.height, this.previousPyramid.data[0]);
          this.previousPyramid.build(this.previousPyramid.data[0]);
          this.isInitialized = true;
        }

        reset() {
          this.isInitialized = false;
        }

        track(imageData, bboxes) {
          if (!this.isInitialized) {
            throw 'not initialized';
          }

          jsfeat.imgproc.grayscale(imageData.data, imageData.width, imageData.height, this.currentPyramid.data[0]);
          this.currentPyramid.build(this.currentPyramid.data[0]);

          // TODO: Move all configuration to config

          let pointsPerObject = (10 + 1) * (10 + 1);
          let pointsCountUpperBound = bboxes.length * pointsPerObject;
          let pointsStatus = new Uint8Array(pointsCountUpperBound);
          let previousPoints = new Float32Array(pointsCountUpperBound * 2);
          let currentPoints = new Float32Array(pointsCountUpperBound * 2);

          let pointsCount = 0;
          for (let i = 0, n = 0; i < bboxes.length; i++) {
            let bbox = bboxes[i];
            if (bbox != null) {
              for (let x = 0; x <= 10; x++) {
                for (let y = 0; y <= 10; y++) {
                  previousPoints[pointsCount*2] = bbox.x + x * (bbox.width / 10);
                  previousPoints[pointsCount*2 + 1] = bbox.y + y * (bbox.height / 10);
                  pointsCount++;
                }
              }
            }
          }

          jsfeat.optical_flow_lk.track(this.previousPyramid, this.currentPyramid, previousPoints, currentPoints, pointsCount, 30, 30, pointsStatus, 0.01, 0.001);

          let newBboxes = [];
          let p = 0;
          for (let i = 0; i < bboxes.length; i++) {
            let bbox = bboxes[i];
            let newBbox = null;

            if (bbox != null) {
              let diffX = [];
              let diffY = [];

              for (let j = 0; j < pointsPerObject; j++, p++) {
                if (pointsStatus[p] == 1) {
                  let x = p * 2;
                  let y = x + 1;

                  diffX.push(currentPoints[x] - previousPoints[x]);
                  diffY.push(currentPoints[y] - previousPoints[y]);
                }
              }

              // TODO: Also compute new width and height

              if (diffX.length > 0) {
                let medianX = jsfeat.math.median(diffX, 0, diffX.length - 1);
                let medianY = jsfeat.math.median(diffY, 0, diffY.length - 1);
                newBbox = new BoundingBox(bbox.x + Math.round(medianX), bbox.y + Math.round(medianY), bbox.width, bbox.height);
              }
            }

            newBboxes.push(newBbox);
          }

          // Swap current and previous pyramids
          let oldPyramid = this.previousPyramid;
          this.previousPyramid = this.currentPyramid;
          this.currentPyramid = oldPyramid; // Buffer re-use

          return newBboxes;
        }
      };

      // Bounding box drawing region

      /**
       * Represents the coordinates of a bounding box
       */
      class BoundingBox {
        constructor(x, y, width, height) {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
        }
      }

      /**
       * Represents a bounding box at a particular frame.
       */
      class AnnotatedFrame {
        constructor(frameNumber, bbox, isGroundTruth) {
          this.frameNumber = frameNumber;
          this.bbox = bbox;
          this.isGroundTruth = isGroundTruth;
        }

        isVisible() {
          return this.bbox != null;
        }
      }

      /**
       * Represents an object bounding boxes throughout the entire frame sequence.
       */
      class AnnotatedObject {
        constructor(dom) {
          this.dom = dom;
          this.frames = [];
        }

        add(frame) {
          for (let i = 0; i < this.frames.length; i++) {
            if (this.frames[i].frameNumber == frame.frameNumber) {
              this.frames[i] = frame;
              this.removeFramesToBeRecomputedFrom(i + 1);
              return;
            } else if (this.frames[i].frameNumber > frame.frameNumber) {
              this.frames.splice(i, 0, frame);
              this.removeFramesToBeRecomputedFrom(i + 1);
              return;
            }
          }

          if (this.frames.length == 0) {
            this.injectInvisibleFramesBefore(frame.frameNumber);
          }
          this.frames.push(frame);
        }

        get(frameNumber) {
          for (let i = 0; i < this.frames.length; i++) {
            let currentFrame = this.frames[i];
            if (currentFrame.frameNumber > frameNumber) {
              break;
            }

            if (currentFrame.frameNumber == frameNumber) {
              return currentFrame;
            }
          }

          return null;
        }

        removeFramesToBeRecomputedFrom(frameNumber) {
          let count = 0;
          for (let i = frameNumber; i < this.frames.length; i++) {
            if (this.frames[i].isGroundTruth) {
              break;
            }
            count++;
          }
          if (count > 0) {
            this.frames.splice(frameNumber, count);
          }
        }

        injectInvisibleFramesBefore(frameNumber) {
          for (let i = 0; i < frameNumber; i++) {
            this.frames.push(new AnnotatedFrame(i, null, false));
          }
        }
      }

      let orchestrator = {
        // TODO: Reset upon change
        frames: {
          totalFrames: () => { return 0; }
        },
        annotatedObjects: [],
        opticalFlow: new OpticalFlow(),
        lastFrame: -1,
        ctx: document.createElement('canvas').getContext('2d'),

        getFrameWithObjects: function(frameNumber) {
          return new Promise((resolve, _) => {
            let startFrame = this.startFrame(frameNumber);
            if (this.annotatedObjects.length == 0 || startFrame == frameNumber) {
              // TODO Return frame with existing annotations
              this.frames.getFrame(frameNumber).then((blob) => {
                blobToImage(blob).then((img) => {
                  resolve(img);
                });
              });
              return;
            }

            this.initOpticalFlow(startFrame).then(() => {
              let i = startFrame + 1;

              let trackNext = () => {
                this.track(i).then((img) => {
                  if (i == frameNumber) {
                    resolve(img);
                  } else {
                    i++;
                    trackNext();
                  }
                });
              };

              trackNext();
            });
          });
        },

        initOpticalFlow: function(frameNumber) {
          return new Promise((resolve, _) => {
            if (this.lastFrame != -1 && this.lastFrame + 1 == frameNumber) {
              resolve();
            } else {
              this.opticalFlow.reset();
              this.frames.getFrame(frameNumber).then((blob) => {
                blobToImage(blob).then((img) => {
                  let imageData = this.imageData(img);
                  this.opticalFlow.init(imageData);
                  this.lastFrame = frameNumber;
                  resolve();
                });
              });
            }
          });
        },

        startFrame: function(frameNumber) {
          for (; frameNumber >= 0; frameNumber--) {
            let allObjectsHaveData = true;

            for (let i = 0; i < this.annotatedObjects.length; i++) {
              let annotatedObject = this.annotatedObjects[i];
              if (annotatedObject.get(frameNumber) == null) {
                allObjectsHaveData = false;
                break;
              }
            }

            if (allObjectsHaveData) {
              return frameNumber;
            }
          }

          throw 'corrupted object annotations';
        },

        track: function(frameNumber) {
          if (this.lastFrame + 1 != frameNumber) {
            throw 'do not call this private method directly';
          }

          return new Promise((resolve, _) => {
            this.frames.getFrame(frameNumber).then((blob) => {
              blobToImage(blob).then((img) => {
                let bboxes = [];
                for (let i = 0; i < this.annotatedObjects.length; i++) {
                  let annotatedObject = this.annotatedObjects[i];
                  let annotatedFrame = annotatedObject.get(frameNumber - 1);
                  if (annotatedFrame == null) {
                    throw 'missing frame';
                  }
                  bboxes.push(annotatedFrame.bbox);
                }

                let imageData = this.imageData(img);
                let newBboxes = this.opticalFlow.track(imageData, bboxes);

                for (let i = 0; i < this.annotatedObjects.length; i++) {
                  let annotatedObject = this.annotatedObjects[i];
                  let annotatedFrame = annotatedObject.get(frameNumber);
                  if (annotatedFrame == null) {
                    annotatedFrame = new AnnotatedFrame(frameNumber, newBboxes[i], false);
                    annotatedObject.add(annotatedFrame);
                  }
                  
                  // TODO: Move to player
                  if (annotatedFrame.isVisible()) {
                    annotatedObject.dom.style.display = 'block';
                    annotatedObject.dom.style.width = annotatedFrame.bbox.width + 'px';
                    annotatedObject.dom.style.height = annotatedFrame.bbox.height + 'px';
                    annotatedObject.dom.style.left = annotatedFrame.bbox.x + 'px';
                    annotatedObject.dom.style.top = annotatedFrame.bbox.y + 'px';
                  } else {
                    annotatedObject.dom.style.display = 'none';
                  }
                }

                this.lastFrame = frameNumber;
                resolve(img);
              });
            });
          });
        },

        imageData: function(img) {
          let canvas = this.ctx.canvas;
          canvas.width = img.width;
          canvas.height = img.height;
          this.ctx.drawImage(img, 0, 0);
          return this.ctx.getImageData(0, 0, canvas.width, canvas.height);
        }
      };

      initDraw(document.querySelector('#doodle'));

      function initDraw(canvas) {
        function setMousePosition(e) {
          let ev = e || window.event;
          if (ev.pageX) {
            mouse.x = ev.pageX;
            mouse.y = ev.pageY;
          } else if (ev.clientX) {
            mouse.x = ev.clientX;
            mouse.y = ev.clientY;
          }
          mouse.x -= canvas.offsetLeft;
          mouse.y -= canvas.offsetTop;
        }

        let mouse = {
          x: 0,
          y: 0,
          startX: 0,
          startY: 0
        };

        let tmpAnnotatedObject = null;

        canvas.onmousemove = function (e) {
          setMousePosition(e);
          if (tmpAnnotatedObject !== null) {
            tmpAnnotatedObject.width = Math.abs(mouse.x - mouse.startX);
            tmpAnnotatedObject.height = Math.abs(mouse.y - mouse.startY);
            tmpAnnotatedObject.x = (mouse.x - mouse.startX < 0) ? mouse.x : mouse.startX;
            tmpAnnotatedObject.y = (mouse.y - mouse.startY < 0) ? mouse.y : mouse.startY;

            tmpAnnotatedObject.dom.style.width = tmpAnnotatedObject.width + 'px';
            tmpAnnotatedObject.dom.style.height = tmpAnnotatedObject.height + 'px';
            tmpAnnotatedObject.dom.style.left = tmpAnnotatedObject.x + 'px';
            tmpAnnotatedObject.dom.style.top = tmpAnnotatedObject.y + 'px';
          }
        }

        canvas.onclick = function (e) {
          if (tmpAnnotatedObject != null) {
            let annotatedObject = new AnnotatedObject(tmpAnnotatedObject.dom);
            let bbox = new BoundingBox(tmpAnnotatedObject.x, tmpAnnotatedObject.y, tmpAnnotatedObject.width, tmpAnnotatedObject.height);
            annotatedObject.add(new AnnotatedFrame(player.currentFrame, bbox, true));
            orchestrator.annotatedObjects.push(annotatedObject);
            tmpAnnotatedObject = null;

            canvas.style.cursor = 'default';
          } else {
            mouse.startX = mouse.x;
            mouse.startY = mouse.y;

            let dom = document.createElement('div');
            dom.className = 'rectangle';
            dom.style.left = mouse.x + 'px';
            dom.style.top = mouse.y + 'px';
            canvas.appendChild(dom);
            tmpAnnotatedObject = { dom: dom };

            canvas.style.cursor = 'crosshair';
          }
        }
      }
    </script>
  </body>
</html>
